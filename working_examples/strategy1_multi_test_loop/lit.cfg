# Strategy 1: Loop-based parameterized approach (Script-based implementation)
#
# This strategy uses a wrapper script to run tests multiple times,
# once for each enabled target, with separate pass/fail reporting.
#
# Pros:
# - Extremely DRY - write test once, runs for all targets
# - Automatically scales with new targets
# - Each target gets its own test result in lit output
# - Avoids custom test format pickling issues
#
# Cons:
# - Uses a wrapper script for test execution
# - Slightly different RUN line syntax

import lit.formats
import os
import subprocess

config.name = 'Cheerp-Strategy1'
config.test_source_root = os.path.dirname(__file__)
config.test_format = lit.formats.ShTest(execute_external=True)
config.suffixes = ['.cpp', '.c']

cheerp_base = '/opt/cheerp/bin/clang++'
cheerp_flags = os.environ.get('CHEERP_FLAGS', '')
extra_flags = os.environ.get('EXTRA_FLAGS', '')
preexecute_mode = os.environ.get('PREEXECUTE_MODE', 'false').lower() == 'true'

cheerp_targets = ["js", "wasm", "asmjs"]
targets_csv = lit_config.params.get("TARGETS", "").strip()

if targets_csv:
    selected_targets = [t.strip().lower() for t in targets_csv.split(",")]
else:
    selected_targets = cheerp_targets

lit_config.note('Strategy 1: Loop-based - Selected targets: {}'.format(selected_targets))

if preexecute_mode:
    lit_config.note('Strategy 1: PREEXECUTION MODE ENABLED')

all_flags = ' '.join(filter(None, [cheerp_flags, extra_flags]))
cheerp_cmd = cheerp_base + (' ' + all_flags if all_flags else '')

# Preexecution-specific flags
preexecute_flags = '-DPRE_EXECUTE_TEST -cheerp-preexecute -mllvm -cheerp-preexecute-main'
if preexecute_mode:
    cheerp_cmd_preexec = cheerp_base + ' ' + preexecute_flags + (' ' + all_flags if all_flags else '')
else:
    cheerp_cmd_preexec = None

# Target mapping
target_map = {
    'js': {'flag': '-target cheerp', 'short': 'j'},
    'wasm': {'flag': '-target cheerp-wasm', 'short': 'w'},
    'asmjs': {'flag': '-target cheerp-asmjs', 'short': 'a'}
}

# Set environment variables for the wrapper script
config.environment["CHEERP_CLANG"] = cheerp_cmd
config.environment["SELECTED_TARGETS"] = ','.join(selected_targets)
config.environment["PREEXECUTE_MODE"] = 'true' if preexecute_mode else 'false'
if preexecute_mode and cheerp_cmd_preexec:
    config.environment["CHEERP_CLANG_PREEXEC"] = cheerp_cmd_preexec

# Create wrapper script paths
wrapper_script = os.path.join(os.path.dirname(__file__), 'run_for_each_target.sh')
wrapper_script_preexec = os.path.join(os.path.dirname(__file__), 'run_for_each_target_preexec.sh')

# For each target, set up compile and run macros
for target in cheerp_targets:
    if target in selected_targets:
        target_info = target_map[target]
        # Compile macro
        config.substitutions.append((
            '%compile_' + target,
            cheerp_cmd + ' ' + target_info['flag']
        ))
        # Execute macro
        config.substitutions.append((
            '%run_' + target,
            'node'
        ))
    else:
        # Disabled target - replace with true
        config.substitutions.append(('%compile_' + target, 'true'))
        config.substitutions.append(('%run_' + target, 'true'))

# Multi-target wrapper that runs all enabled targets
if preexecute_mode:
    config.substitutions.append(('%run_all_targets', wrapper_script_preexec))
else:
    config.substitutions.append(('%run_all_targets', wrapper_script))

# Base substitutions
config.substitutions.append(('%FileCheck', '/usr/bin/FileCheck-20'))
config.substitutions.append(('%node', 'node'))

config.test_exec_root = os.path.dirname(__file__)
# Ensure Cheerp tools (like llc for -cheerp-no-lto) are in PATH
if 'PATH' in os.environ:
    config.environment['PATH'] = '/opt/cheerp/bin:' + os.environ['PATH']
else:
    config.environment['PATH'] = '/opt/cheerp/bin:/usr/bin:/bin'
